---
title: "Underused gems of the web: WebWorkers"
date: "2022-06-17"
updatedAt: "2022-07-20"
authors: ["nicky"]
cover: "./cover.jpg"
tags: ["JavaScript"]
---

import { ProblemDemo, SolutionDemo, WebWorkerDemo } from "./";

<!-- Photo by <a href="https://unsplash.com/@rewdew?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Kyle Larivee</a> on <a href="https://unsplash.com/s/photos/bus-lane?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
 -->

The browsers we use to surf the web are amazing pieces of technology.
But they do a lot of work to make it possible for me to watch cat videos.

Over the years, website have gotten orders of magnitude more complicated.
Without going into detail, many sites are now classified as "apps".
They're no longer static documents.
Those sites have to do much more work.

Nowadays, each tab in a browser has its own thread.

<Aside variant="info">

A thread can be thought of as a place in your computer where work happens.
It does one thing at a time.
In [Concurrent vs parallel](/garden/concurrent-vs-parallel) I
explain what the difference is between concurrency and parallellism.

</Aside>

Within that tab, you are bound to that one thread <small>(pretty much)</small> that does <small>nearly</small> **everything**.

It parses the document, executes JavaScript, lays out all things and paints them to the screen.
All these steps take time.

Oh, it also processes user interactions (things like a hover).
It's a lot of work, and we keep adding to it.

A large part of the work is (in)directly caused by executing JavaScript.

## A problem

**JavaScript is a single threaded language.**

That's a problem.

JavaScript was designed around the concept of having access to a single thread.

This greatly simplifies a lot of programming in JavaScript (before writing the post, I had literally never thought about [race conditions](https://en.wikipedia.org/wiki/Race_condition) in JS).
But it also comes with a bunch of downsides.

<Aside variant="info">

Adding threading and shared memory support to everything now would cause a lot of problems.

That's why the concept of shared memory was isolated to a single type: [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer).
More on that later.

</Aside>

The biggest downside comes in the form of user experience.

When that main thread is busy, it's can't do anything else, like responding to your clicks or scrolls.

<Aside variant="info">

Browser vendors know this is a problem, so they use threads internally to keep the user experience of browsing the web as smooth as possible.

Some examples:

- [An animated .gif keeps animating in Chromium browsers](https://developer.chrome.com/articles/renderingng-architecture/#threads) because that's handled by a seperate thread.
- [Scrolling with a blocked main thread is still possible](https://blogs.windows.com/msedgedev/2017/03/08/scrolling-on-the-web/) because it's done on a different thread.
- [Some CSS animations keep animating](https://web.dev/non-composited-animations/) with a blocked thread because they are handled on a thread called the "compositor thread".

</Aside>

### Demo

This demo has a button that blocks the main thread for three seconds with a `while` loop.
During the time the browser is blocked, several things are noticible.

1. You can no longer select text
1. The JS Animation froze
1. Your browser cursor, and the hover styles don't change
1. You cannot increment the counter on the page

A second button exists that doesn't fully block the browser for three seconds, but causes what's known as "jank".
It causes some chunks of JavaScript work.
During each chunk, the browser is unresponsive as before, but in between, it can ship a frame and react to user actions.

That is why you can still increment the counter.
The animation doesn't come to a complete standstill, but it has an ugly "start-stop"-behaviour.

<ProblemDemo />

## A solution

In other words, [not threading makes your event listeners sad](https://macarthur.me/posts/use-web-workers-for-your-event-listeners).

Eventhough I just said JavaScript is a single threaded language and doesn't have threads, you can still use multiple threads on the web!

The browser has the [Web Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) for this.

A Web Worker executes your code in a new thread that has an entire seperate [execution context](https://www.youtube.com/watch?v=Fd9VaW0M7K4).
You can think of it like a seperate tab without a UI. It shares nothing with the main thread.

It's has its own event loop, but this loop isn't responsible for shipping frames to the browser, only the main thread is.

<Aside variant="success">

This talk about the [event loop](https://www.youtube.com/watch?v=cCOL7MC4Pl0) is great and I highly recommend watching it.

</Aside>

While blocking the event loop on the main thread will stop new frames from being shipped,
blocking a Web Worker leaves the main thread free to respond to user interaction and ship new frames.

### Demo

The same demo as before, only this time the first two buttons do not affect the main thread, but a worker thread.

The main thread is entirely unaffected.

I promise that a worker thread is doing the same heavy work as the main thread did in the previous demo.
This isn't a magic trick.
Open your system monitor and you will see a jump in CPU usage when you click on a button.

<SolutionDemo />

---

TODO:
leaving my notes visible here while I write

This won't make your app faster if that logic isn't parallellizable, on the contrary, the postMessage calls aren't magic, they aren't free.
While the worker is busy, the main thread stays free and is able to react to user interaction and ship updated frames to the browser (eg. hovering over a button)
It's often better to make the user wait a little bit longer than to drop a frame.
The time to drop a frame is on the order of milliseconds.
The time to maka a user wait is on the oder os 100s of milliseconds.
-DasSurma in https://www.youtube.com/watch?v=7Rrv9qFMWNM

You are moving execution costs off the main thread.
If that logic uses a module that the main thread doesn't need, you're also moving paring costs off the main thread.
This makes that initial load performance better.
Your UI thread is ready to show something faster: better FCP and TTI
-link that firebase blogpost-

WEBWORKERS have been around since IE10

Webworkers aren't silver bullets that solve all problems.

> Silver bullets only work on werewolf-shaped problems
>
> <footer>
>
> [Sunil Pai](https://twitter.com/threepointone) (paraphrased)
>
> </footer>

## Demo

Try calling Adele while counting (in a webworker).

<WebWorkerDemo />
