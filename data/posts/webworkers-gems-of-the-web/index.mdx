---
title: "Underused gems of the web: WebWorkers"
date: "2022-06-17"
updatedAt: "2022-07-20"
authors: ["nicky"]
cover: "./cover.jpg"
tags: ["JavaScript"]
---

import {
  ProblemDemo,
  SolutionDemo,
  MainToWorkerChart,
  WebWorkerDemo,
} from "./";

<!-- Photo by <a href="https://unsplash.com/@rewdew?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Kyle Larivee</a> on <a href="https://unsplash.com/s/photos/bus-lane?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
 -->

The browsers we use to surf the web are amazing pieces of technology.
But they do a lot of work to make it possible for me to watch cat videos.

Over the years, website have gotten orders of magnitude more complicated.
Without going into detail, many sites are now classified as "apps".
They're no longer static documents.
Those sites have to do much more work.

Nowadays, each tab in a browser has its own thread.

<Aside variant="info">

A thread can be thought of as a place in your computer where work happens.
It does one thing at a time.
In [Concurrent vs parallel](/garden/concurrent-vs-parallel) I
explain what the difference is between concurrency and parallellism.

</Aside>

Within that tab, you are bound to that one thread <small>(pretty much)</small> that does <small>nearly</small> **everything**.

It parses the document, executes JavaScript, lays out all things and paints them to the screen.
All these steps take time.

Oh, it also processes user interactions (things like a hover).
It's a lot of work, and we keep adding to it.

A large part of the work is (in)directly caused by executing JavaScript.

## A problem

**JavaScript is a single threaded language.**

That's a problem.

JavaScript was designed around the concept of having access to a single thread.

This greatly simplifies a lot of programming in JavaScript (before writing the post, I had literally never thought about [race conditions](https://en.wikipedia.org/wiki/Race_condition) in JS).
But it also comes with a bunch of downsides.

<Aside variant="info">

Adding threading and shared memory support to everything now would cause a lot of problems.

That's why the concept of shared memory was isolated to a single type: [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer).

</Aside>

The biggest downside comes in the form of user experience.

When that main thread is busy, it's can't do anything else, like responding to your clicks or scrolls.

<Aside variant="info">

Browser vendors know this is a problem, so they use threads internally to keep the user experience of browsing the web as smooth as possible.

Some examples:

- [An animated .gif keeps animating in Chromium browsers](https://developer.chrome.com/articles/renderingng-architecture/#threads) because that's handled by a seperate thread.
- [Scrolling with a blocked main thread is still possible](https://blogs.windows.com/msedgedev/2017/03/08/scrolling-on-the-web/) because it's done on a different thread.
- [Some CSS animations keep animating](https://web.dev/non-composited-animations/) with a blocked thread because they are handled on a thread called the "compositor thread".

</Aside>

### Demo

This demo has a button that blocks the main thread for three seconds with a `while` loop.
During the time the browser is blocked, several things are noticible.

1. You can no longer select text
1. The JS Animation froze
1. Your browser cursor, and the hover styles don't change
1. You cannot increment the counter on the page

A second button exists that doesn't fully block the browser for three seconds, but causes what's known as "jank".
It causes some chunks of JavaScript work.
During each chunk, the browser is unresponsive as before, but in between, it can ship a frame and react to user actions.

That is why you can still increment the counter.
The animation doesn't come to a complete standstill, but it has an ugly "start-stop"-behaviour.

<ProblemDemo />

## A solution

In other words, [not threading makes your event listeners sad](https://macarthur.me/posts/use-web-workers-for-your-event-listeners).

Eventhough I just said JavaScript is a single threaded language and doesn't have threads, you can still use multiple threads on the web to do work in parallel!

The browser has the [Web Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) for this.

A Web Worker executes your code in a new thread that has an entire seperate [execution context](https://www.youtube.com/watch?v=Fd9VaW0M7K4).
You can think of it like a seperate tab without a UI. It shares nothing with the main thread.

It's has its own event loop, but this loop isn't responsible for shipping frames to the browser, only the main thread is.

<Aside variant="success">

This talk about the [event loop](https://www.youtube.com/watch?v=cCOL7MC4Pl0) is great and I highly recommend watching it.

</Aside>

While blocking the event loop on the main thread will stop new frames from being shipped,
blocking a Web Worker leaves the main thread free to respond to user interaction and ship new frames.

A real-world analogue would be a street with two lanes.
One lane represents the main thread and the second lane represents a web worker.
The second lane is a dedicated bus lane.
When the main lane is blocked, that doesn't affect the buslane and vice versa.

### Demo

The same demo as before, only this time the first two buttons do not affect the main thread, but a worker thread.

The main thread is entirely unaffected.

I promise that a worker thread is doing the same heavy work as the main thread did in the previous demo.
This isn't a magic trick.
Open your system monitor and you will see a jump in CPU usage when you click on a button.

<SolutionDemo />

## How

The [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Worker/Worker) API has been around for a long time. Since IE10.

[The browser support for web workers](https://caniuse.com/webworkers) is excellent, it's even better than [the browser support for `fetch`](https://caniuse.com/mdn-api_fetch).

A worker can be created by passing the path to a seperate JavaScript file to its constructor.

```js title=index.js
const worker = new Worker("./worker.js");
```

Everything in that file will be executed in a seperate thread.
Because of [the required isolation](#a-problem) between the main thread and a worker thread, the threads don't have access to any variables or other code from eachother.

This combined with the fact that workers have an entirely seperate execution context means they don't have access to a bunch of things you expect to "just be there", like the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model).
In other words: web workers can't update the UI directly!

An other result of that isolation is that the threads have to exchange data by passing messages.

This is done through the [`postMessage` API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
It will copy the message, and fire an event in the other thread with that copied data.

<MainToWorkerChart />

On the main thread, the `postMessage` function is available on that `worker` object you got from calling the `new Worker()` constructor.

In the worker file, `postMessage` is one of the functions global to the worker.

On both sides, you can listen to the `"message"` event this causes.
The data you provided as an argument to `postMessage` will be available on the `.data` property of the event.

To listen to that event, add an [`addEventListener` method](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener).
On the main thread, that method is available on the worker object.

In the worker, it's the same deal as with `postMessage`.
The `addEventListener` method is available on the [global webworker scope](https://developer.mozilla.org/en-US/docs/Web/API/DedicatedWorkerGlobalScope).

This way, the threads can still communicate with eachother while adhering to that needed strict seperation, great!

This method of using webworkers can be summed up in the same way the [Go programming language](https://go.dev/) approaches multithreading.

> Don't communicate by sharing memory; share memory by communicating.
>
> <footer>
>
> [The Go docs](https://go.dev/doc/codewalk/sharemem/#:~:text=Go's%20approach%20to%20concurrency%20differs,to%20data%20structures%20between%20goroutines.)
>
> </footer>

You can handle different messages with your favourite method of controlling code flow.
In this example, I used a `switch` statement to respond differently to certain messages.

```js title=index.js
const worker = new Worker("./worker.js");
worker.addEventListener("message", (event) => {
  console.log(event.data);
});

worker.postMessage("tick");
```

```js title=worker.js
addEventListener("message", (event) => {
  switch (event.data) {
    case "tic": {
      postMessage("tac");
      break;
    }
    case "ping": {
      postMessage("pong");
      break;
    }
    default: {
      postMessage("A hotdog is a sandwich");
    }
  }
});
```

This example used strings as arguments to `postMessage`, but it can handle way more.

`postMessage` uses the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm) to copy the messages.
It can handle a lot!

Even complex data structures like `Map` and `Set`, or cyclical data structures.
It can't handle functions, trying to copy those will cause an error.
A class will be converted to a standard JavaScript object, losing methods in the process.

<Aside variant="success">

[The `structuredClone()` method](https://developer.mozilla.org/en-US/docs/Web/API/structuredClone) is available directly too!
You can use it to make deep clones of things.

no mo' lodash!

```js
const original = makeLinkedList();
const clone = structuredClone(original);
```

</Aside>

## The main thread is still needed

Sometimes, even if your code doesn't touch the DOM.
You still need to run it on the main thread as a bunch of APIs aren't available in workers.

<Aside variant="info">

[The list of web APIs available in a worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API#supported_web_apis) is quite large.

It doesn't include a bunch of APIs that are available on the main thread though. (eg. `Image`, `Video`, `USB`)
I hope that list grows smaller and smaller as time goes on.
The less I have to think about the difference between code I write for the main thread versus for a web worker, the better.

</Aside>

But because we cannot move everything to a worker doesn't mean we should abandon it altogether for those chunks of work.
A webworker still might be able to perform most of the work before passing off a result to the main thread that then handles the needed mainthread work.

The following example expands on the previous one.
It plays a sound-clip in response to a message of a certain type.

The messages sent to and from the worker are now objects with a `type` property.
This is done to make it possible to send messages with seperate data attached to them.

If you ever worked with the Flux-pattern (like [Redux](https://redux.js.org/usage/reducing-boilerplate#actions)), these messages might seem familiar.

They're actions.
In fact, [the actor model](https://www.youtube.com/watch?v=Vg60lf92EkM) is a perfect fit here.

Because `Audio` is one of those APIs that _needs_ the main thread, it is created and listened to on the main thread.
But everything involved in getting the things that audio object needs to be created in the first place is done on the worker thread.

```js title=index.js numberLines hl=4,7,20
const worker = new Worker("./worker.js");

worker.addEventListener("message", (event) => {
  switch (event.data.type) {
    // ...
    case "hiResponse": {
      const audio = new Audio(event.data.audioPath);
      audio.addEventListener("ended", () => {
        console.log("It's quiet...");
      });
      audio.play();
      break;
    }
    default: {
      console.log(event.data);
    }
  }
});

worker.postMessage({ type: "hi" });
```

The callback that is passed to the event listener is now `async` in order to be able to use `await` in combination with the call to `fetch`.

```js title=worker.js numberLines hl=1-2,5,9
addEventListener("message", async (event) => {
  switch (event.data.type) {
    // ...
    case "hi": {
      const res = await fetch("./cereal-is-soup.json");
      const json = await res.json();
      // ...lots of data janitor work here...
      const audioPath = json.audioPath;
      postMessage({ type: "hiResponse", audioPath });
      break;
    }
    // ...
  }
});
```

## Importing packages

Using code you didn't write is ubiquitous.
Web workers originally weren't built with module imports in mind, because modules didn't exist yet.

That changed!

The `Worker` constructor takes an options object where you can specify it will use modules.

You can now `import` inside a webworker, yay!

```js title=index.js
const worker = new Worker("worker.js", {
  type: "module",
});
```

<Aside variant="info">

The [browser support for module workers](https://caniuse.com/mdn-api_worker_worker_ecmascript_modules) one is decent, but Firefox is lagging behind.
This is being [actively worked on](https://bugzilla.mozilla.org/show_bug.cgi?id=1247687), so expect support soon™.

If you use a bundler for your code like [Webpack](https://webpack.js.org/), [Vite](https://vitejs.dev/), ... this will be supported regardless of browser.
If you do not, be aware Firefox (and IE) don't support ESModules in workers.

</Aside>

Expanding on the example again, let's import a heavy [machine vision](https://en.wikipedia.org/wiki/Machine_vision) library that detects what object is in a photo.

The photo grabbed from a `canvas` element as an [`ImageData` object](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).
Because it's so big, cloning all that data would take a large amount of time.
It's [**transferred** to the worker](https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects) instead of copied.

```js title=index.js numberLines hl=1,33-35
const worker = new Worker("./worker.js", { type: "module" });

worker.addEventListener("message", (event) => {
  switch (event.data.type) {
    // ...
    case "detectionResult": {
      console.log(
        `There was ${
          event.data.result === true ? "a" : "no"
        } sandwich in this picture`
      );
      break;
    }
    default: {
      console.log(event.data);
    }
  }
});

const input = document.querySelector("input");
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

input.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  const bitmap = await createImageBitmap(file);

  canvas.height = bitmap.height;
  canvas.width = bitmap.width;
  ctx.drawImage(bitmap, 0, 0);
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  worker.postMessage({ type: "isSandwich", imageData }, [
    imageData.data.buffer,
  ]);
});
```

```js title=worker.js numberLines
import { whatIsThis } from "some-machine-vision-library";

addEventListener("message", async (event) => {
  switch (event.data.type) {
    // ...
    case "isSandwich": {
      const item = await whatIsThis(event.data.imageData);
      postMessage({ type: "detectionResult", result: item === "hotdog" });
      break;
    }
    default: {
      postMessage("A hotdog is a sandwich");
    }
  }
});
```

---

## Performance

-a Paul Lewis post-

Using more than one thread won't make your app any faster if the logic it uses isn't parallellizable, on the contrary, calls to `postMessage` aren't magic, they aren't free.

For most uses, using a webworker means moving a chunk of work to a worker thread unchanged.
The overall amount of work will rise slightly due to the added overhead between the worker and the main thread.
The big difference is that the main thread is able to react to user events and ship updates frames while that chunk of work is happening in a worker.

> It's often better to make the user wait a little bit longer than to drop a frame.
> The time to drop a frame is on the order of milliseconds.
> The time to maka a user wait is on the oder os 100s of milliseconds.
>
> <footer>
>   [Surma](https://twitter.com/DasSurma) in [The main thread is overworked &
>   underpaid](https://www.youtube.com/watch?v=7Rrv9qFMWNM)
> </footer>

TODO: mention the performance of the device your code runs on is unknown to you.
On your dev machine, a function might complete in 10ms, but on your friend's slow phone, it takes a whopping 200ms.
also: different screen Hz.
60 popular, 1s/60frames is 16,666ms that available per frame.
but EVERYTHING has to happen inside that timeframe if you want the browser to ship a frame: from running your JS, to calculating the layout, to painting the screen and compositing.
-insert render pipeline post-

### `postMessage`

About that cost of `postMessage`.
Surma wrote a great post called [is `postMessage` slow](https://surma.dev/things/is-postmessage-slow/).

The TL;DR is: payloads up to 10KiB are risk-free. (and 10 kilobytes is quite a lot)

#### Transferring objects

transfer objects
transferred objects are no longer available after they are transferred.

```diff
-   worker.postMessage({ type: "isSandwich", imageData });
+   worker.postMessage({ type: "isSandwich", imageData }, [
+   imageData.data.buffer,
+ ]);
```

### load

You are moving execution costs off the main thread.
If that logic uses a module that the main thread doesn't need, you're also moving paring costs off the main thread.
This makes that initial load performance better.
Your UI thread is ready to show something faster: better FCP and TTI
-link that firebase blogpost-

## It's time to stop

`webworker.terminate()` on the main thread and that thing you call in a webworker that has a different name because the web is a mess and standards are weird sometimes.

## show progress

TODO:
leaving my notes visible here while I write

Webworkers aren't silver bullets that solve all problems.

> Silver bullets only work on werewolf-shaped problems
>
> <footer>
>
> [Sunil Pai](https://twitter.com/threepointone) (paraphrased)
>
> </footer>

## Demo

Try calling Adele while counting (in a webworker).

<WebWorkerDemo />
