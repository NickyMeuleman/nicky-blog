---
title: WebAssembly. Scary name, exciting applications.
date: "2021-11-28"
authors: ["nicky"]
cover: "./cover.jpg"
tags: ["WebAssembly", "Rust"]
---

import { GOLDemo } from "./";

<!-- Foto door Pietro Battistoni via Pexels -->

<Aside passedSx={{fontStyle:"normal"}}>

WebAssembly oversimplified:  
‚ö° Consistently fast  
üî¨ Small  
üåç Universal  
‚ôª Promotes code re-use

</Aside>

## What

After HTML, CSS, and JavaScript, WebAssembly is the fourth [official](https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en) language of the web.

> WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine.
> Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.
>
> <footer>
>
> [The WebAssembly homepage](https://webassembly.org/)
>
> </footer>

I think that quote just won buzzword bingo. (And it used to be even more confusing, calling C/C++/Rust high-level languages).
I'll try to break it down.

A WebAssembly `.wasm` file consists of a bunch of binary instructions, it's meant for computers and is not human-readable.

Those instructions are not for a physical machine but for a pretend one, a _virtual_ machine.

Normally, binary code is specific to a physical chip architecture and won't work on different kinds of chips.
Because WebAssembly gives instructions to a virtual machine, it will work on all kinds of different chip architectures.
ARM, Intel, AMD, you name it, it can execute WebAssembly.

This is possible because the machine WebAssembly targets is the lowest common denominator of popular hardware.
Allowing all kinds of physical chips to translate those universal WebAssembly instructions to the ones and zeroes that are specific to that architecture,
and put specific patterns of lightning into the sand we call a CPU to trick it into doing math.

The instructions in a `.wasm` file are for a [stack machine](https://en.wikipedia.org/wiki/Stack_machine).
Chris Hay has [a great primer video](https://youtu.be/Hq_cj77fuqo) on how this works.
The tl;dr is: push things on a stack, do things with the numbers on the stack, pop things off the stack.

The specifics of which are very interesting, but not necessary knowledge.
That is common theme in my deep dive into WebAssembly.
Knowing how things work is optional, if you don't want to know details, that's totally fine because there are a bunch of great tools that abstract them away.

A textual representation of a `.wasm` file is called a `.wat` file.
That stands for **W**ebAssembly **T**ext **F**ormat.
The first letters of that accurately describe my reaction when I first saw a `.wat` file.

It's human readable, but at first glance I thought _"not to this human"_. ([Jake Archibald](https://youtu.be/u0Jgz6QVJqg?t=53) had a similar reaction).

```wat title=math.wat
(module
    (func $square (param i32) (result i32)
        local.get 0
        local.get 0
        i32.mul
    )
    (export "square" (func $square))
)
```

The small snippet above gets the first parameter (at index 0, because that's how computers start counting) and puts it on the stack.
It does the same thing again so there are now 2 identical numbers on the stack.
Then it gives the multiplication instruction that pops 2 numbers off the stack, multiplies them, and puts the result back onto the stack.
Bingo, bango, a function that squares a number.

Surma explains how to read it in much greater detail in his [raw wasm blogpost](https://surma.dev/things/raw-wasm/index.html).

While you can write `.wat` files by hand and convert those to `.wasm`, you probably never will.

<abbr title="WebAssembly">WASM</abbr> is designed to be a compilation target for
other languages.

You write in an other language, run some tool, and usable WASM comes out.
Right now, the languages with the best support are lower-level languages like C/C++/Rust,
because they manage the use of memory themselves and don't need a [garbage collector](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>).

### WebAssembly is a misnomer

WebAssembly is [_‚ÄúNeither Web, Nor Assembly‚Äù_](https://www.javascriptjanuary.com/blog/webassembly-neither-web-nor-assembly-but-revolutionary).

It's a language that can run in the browser, but can also run outside of it.

A `.wasm` file is a binary file, it isn't assembly text.
The `.wat` format is a textual representation that more closely resembles assembly.

It's assembly for a virtual machine too, where traditional assembly is directly giving instructions to a phyisical chip.

## Why

### Fast

Wasm goes **predictably** fast.

The speed at which JavaScript can go is impressive.
This is achieved by modern JavaScript runtimes that do [just in time compiling](https://en.wikipedia.org/wiki/Just-in-time_compilation).

[Speed, Speed, Speed by Franziska Hinkelmann](https://www.youtube.com/watch?v=uMuYaES4W3o&t=739s) goes into this.

JavaScript has to go through more steps before it ends turned into optimized machine code, each of those steps taking time.
To make optimized machine code, JS has to execute pieces of code first.
The JavaScript runtime uses the information it gathered while the JS was executing to generate that faster machine code.
This process can repeat over and over with an end result of fairly efficient machine code.

An additional problem is that while doing this, the engine might make certain assumptions that help execution speed.
These assumptions might have held the first 5000 times a piece of code was executed, but aren't true anymore the 5001th time.
If that happens, the runtime falls back to a previous, slower step ([the interpreter](<https://en.wikipedia.org/wiki/Interpreter_(computing)>)).
This is called a deoptimization.

Combined, this results in unpredictable performance when running JavaScript.

It would be an overgeneralization to say that machine code is always faster than interpreted code (how JavaScript is initially executed), but on average, it's probably true.

The path to machine code is much shorter for WASM.
As soon as the WASM is loaded, it gets turned into machine code.

This translation is fast, so fast that it's faster than downloading the `.wasm` file in most cases.

It's possible to compile the `.wasm` to a baseline machine code as it comes in over the network.
This is called streaming compilation, and can be done in the browser with the [`instantiateStreaming` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming).

Once the WebAssembly is fully loaded, the [same optimizing compiler](https://v8.dev/docs/turbofan) that was used when executing JavaScript kicks in and swaps out the baseline compiled version for the faster, optimized version.

#### Replacing hot paths with WASM code

The post where Surma details [replacing a hot path in your app's JavaScript with WASM](https://developers.google.com/web/updates/2019/02/hotpath-with-wasm) is really good.

### Code reuse

The JavaScript ecosystem is pretty huge, there are a staggering amount of packages on [npm](https://www.npmjs.com/).
But JavaScript is not the first choice to solve all coding problems.

Many solutions to problems might exist, but have a much more extensive solution in other languages like C or Rust.
An other possibility is that these solutions don't exist at all in JavaScript while there are packages in those other languages.

Using WebAssembly, you can tap into an other language's ecosystem.

Like a picture encoder written 30 years ago in C? Compile it to WASM and put it in the browser!
This isn't a hyperbole, it's exactly what [squoosh.app](https://squoosh.app/) is doing.
They use algorithms from other languages to bring image compressions to the web.

[Google Earth is now available in more browsers](https://medium.com/google-earth/google-earth-comes-to-more-browsers-thanks-to-webassembly-1877d95810d6) thanks to WebAssembly.
(They used a proprietary technology that was only available in Chrome previously)

[Photoshop is now on the web](https://www.theverge.com/2021/10/26/22738125/adobe-photoshop-illustrator-web-announced).

[AutoCAD came to the web](https://youtu.be/BnYq7JapeDA?t=1332).

These last 3 examples are _huge_ codebases that didn't need to be entirely rewritten to target a much broader audience.

The web is the largest and most ubiquitous delivery platform in existence.
The expansion of the capabilities of the web is exciting.

## When

Now

-caniuse statistics-

## How

### What makes WASM work?

WASM is very bare-bones, that means that for fairly simply functionality, a JavaScript file can be smaller/faster.
Because the JS can leverage all the code the JavaScript runtime (like [v8](https://v8.dev/)) already provides.

In WASM, if you need something, that code has to be included in the `.wasm` file.
Examples are: Dynamic memory allocation, using strings, or an array implementation.
Oh. You used a method on that array? Better include the logic for that too.

Luckily, that's all code you don't need to write yourself, language specific tools like [wasm-bindgen for Rust](https://rustwasm.github.io/docs/wasm-bindgen/) or [emscripten for C](https://emscripten.org/) handle that,
meaning you can write code as usual, and they make sure the needed bits are included to use the `.wasm` file.

If this all sounds like something like this happened before, it's because it did.
The [JVM](https://nl.wikipedia.org/wiki/Java_Virtual_Machine) is an example of something similar to WASM.
The reasons for creating a new thing with WASM instead of going down the JVM road again are very technical (like the security story, how it is compiled, yada, yada, yada).

WebAssembly is sandboxed, just like JavaScript is. It can‚Äôt access the user‚Äôs operating system directly
security: good, but not perfect and [closesly looked at](https://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf).

-lin clarks talk on security and the least authority thing-
A lot of that boils down to: being able to use C code means you can do things that are possible in C,
like making a pointer point at the wrong value.
Using a language like Rust mitigates even more of those risks, but of course, nothing is 100% safe.

-points from Lin Clark talk about JS in WASM with WISER etc, it's faster to start up but slower to execute because the optimizing compiler stuff isn't there -

### How do I use WASM?

https://github.com/NickyMeuleman/wasm-examples

## Demo

<GOLDemo />

## More examples

[Figma is a React app that uses WASM to do the computationally intensive logic.](https://www.figma.com/blog/webassembly-cut-figmas-load-time-by-3x/)

The Facebook picture uploader uses WASM to do some quick transformations to images.

[DOOM3 in the browser](https://wasm.continuation-labs.com/d3demo/).

[The original DOOM](https://silentspacemarine.com/) on Cloudflare's edge network.

[BBC iPlayer](https://medium.com/bbc-design-engineering/building-a-webassembly-runtime-for-bbc-iplayer-and-enhanced-audience-experiences-7087455808ef).

TODO: find more things readers will have already used

notes: investigate https://suborbital.dev/. serveless wam y'all
