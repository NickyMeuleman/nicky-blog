---
title: WASM on the jamstack
date: "2021-11-12"
authors: ["nicky"]
cover: "./cover.jpg"
tags: ["WebAssembly", "Rust"]
---

import { GOLDemo } from "./";

<!-- Foto door Pietro Battistoni via Pexels -->

<Aside passedSx={{fontStyle:"normal"}}>

WebAssembly oversimplified:  
‚ö° Consistently fast  
üî¨ Small  
üåç Universal  
‚ôª Promotes code re-use

</Aside>

## What

After HTML, CSS, and JavaScript, WebAssembly is the fourth [official](https://www.w3.org/2019/12/pressrelease-wasm-rec.html.en) language of the web.

> WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine.
> Wasm is designed as a portable compilation target for programming languages, enabling deployment on the web for client and server applications.
>
> <footer>
>
> [The WebAssembly homepage](https://webassembly.org/)
>
> </footer>

I think they just won buzzword bingo. (And it used to be even more confusing, calling C/C++/Rust high-level languages).
I'll try to break it down.

A WebAssembly `.wasm` file consists of a bunch of binary instructions, it's meant for computers and is not human-readable.

Those instructions are not for a physical machine, but for a pretend one, a _virtual_ machine.

Normally, binary code is specific to a physical chip and it won't work on different kinds of chips.
Because WebAssembly gives instructions to that virtual machine, it will work on all kinds of different chip architectures.
ARM, Intel, AMD, you name it, it can execute WebAssembly.

This is possible because a goal of WebAssembly is to target the lowest common denomenator.
Allowing all kinds of chips to translate those universal WebAssembly instructions to the ones and zeroes that are specific to that architecture,
and put the specific patterns of lightning into the sand we call a CPU.

The instructions in a `.wasm` file are for a [stack machine](https://en.wikipedia.org/wiki/Stack_machine).
Chris Hay has [a great primer video](https://youtu.be/Hq_cj77fuqo) on how this works.
The tl;dr is: push things on a stack, do things with the numbers on the stack, pop things off the stack.

The specifics of which are very interesting, but not necessary knowledge.
That is common theme in my deep dive into WebAssembly by the way.
Knowing how things work is optional, if you don't want to know details, that's totally fine, because there are a bunch of great tools that abstract them away.

A textual representation of a `.wasm` file is called a `.wat` file.
That stands for **W**ebAssembly **T**ext **F**ormat.
The first letters of that accurately describe my reaction when I first saw a `.wat` file.

It's human readable, but at first glance I thought "not to this human". (An identical reaction as [Jake Archibald](https://twitter.com/jaffathecake)).

```wat title=math.wat
(module
    (func $square (param i32) (result i32)
        local.get 0
        local.get 0
        i32.mul
    )
    (export "square" (func $square))
)
```

The small snippet above gets the first parameter (at index 0, because that's how computers start counting) and puts it on the stack.
It does the same thing again so there are now 2 identical numbers on the stack.
Then it gives the multiplication instruction that pops 2 numbers off the stack, multiplies them, and puts the result back onto the stack.
Bingo, bango, a function that squares a number.

Surma explains how to read it in much greater detail in his [raw wasm blogpost](https://surma.dev/things/raw-wasm/index.html).

While you can write `.wat` files by hand and convert those to `.wasm`, you probably never will.

<abbr title="WebAssembly">WASM</abbr> is designed to be a compilation target for
other languages.

You write in an other language, run some tool, and usable WASM comes out.
Right now, the languages with the best support are lower-level languages like C/C++/Rust, because they manage the use of memory themselves, and don't need a [garbage collector](<https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)>).

### WebAssembly is a misnomer

WebAssembly is [‚ÄúNeither Web, Nor Assembly‚Äù](https://www.javascriptjanuary.com/blog/webassembly-neither-web-nor-assembly-but-revolutionary).

It's a language that can run in the browser, but can also run outside of it.

A `.wasm` file is a binary file, it isn't assembly text.
The `.wat` format is a textual representation that more closely resembles assembly.

It's assembly for a virtual machine too, where traditional assembly is directly giving instructions to a phyisical chip.

## Why

- It goes **predictably** fast.
- It's small.
- It means you can reuse code written in other languages.

Like a picture encoder written 30 years ago in C? Compile it to WASM and put it in the browser!
This isn't a hyperbole, it's what's happening and the exact usecase of using those image algorithms is being used in web tools like [squoosh.app](https://squoosh.app/).

AutoCAD on the web.
Photoshop on the web.
Figma.
The Facebook picture uploader.
TODO: find more things readers will have already used

## When

Now

-caniuse statistics-

## How

WASM is very bare-bones, that means that for fairly simply functionality, a JavaScript file can be smaller/faster.
Because the JS can leverage all the code the JavaScript runtime (like [v8](https://v8.dev/)) already provides.

In WASM, if you need something, that code has to be included in the `.wasm` file.
Examples are: Dynamic memory allocation or an array implementation.
Oh. You used a method on that array? Better include the logic for that too.

Luckily, that's all code you don't need to write yourself, language specific tools like [wasm-bindgen for Rust](https://rustwasm.github.io/docs/wasm-bindgen/) or [emscripten for C](https://emscripten.org/) handle that,
meaning you can write code as usual, and they make sure the needed bits are included in the `.wasm` file.

If this all sounds like it already happened before, it's because it did.
The [JVM](https://nl.wikipedia.org/wiki/Java_Virtual_Machine) is an example of something similar to WASM.
The reasons for creating a new thing with WASM instead of going down the JVM road again are very technical (like the security story, how it is compiled, yada, yada, yada).

WebAssembly is sandboxed, just like JavaScript is. It can‚Äôt access the user‚Äôs operating system directly
security: good, but not perfect and [closesly looked at](https://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf).

-lin clarks talk on security and the least authority thing-
A lot of that boils down to: being able to use C code means you can do things that are possible in C,
like making a pointer point at the wrong value.
Using a language like Rust mitigates even more of those risks, but of course, nothing is 100% safe.

-points from Lin Clark talk about JS in WASM with WISER etc, it's faster to start up but slower to execute because the optimizing compiler stuff isn't there -

## Demo

<GOLDemo />
