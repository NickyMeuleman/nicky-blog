---
title: "Rust: expression vs statement"
date: "2020-09-23"
authors: ["nicky"]
tags: ["rust"]
---

<Aside>

TL;DR: Expressions evaluate to a value, they return that value.
Statements do not.

</Aside>

Statements are instructions that _do_ something, they don't return a value.
Expressions _evaluate to a value_, they return that value.

> Rust is an expression-oriented language.
> This means that most things are expressions, and evaluate to some kind of value.
> However, there are also statements.
>
> <footer>Steve Klabnik (member of the Rust core team)</footer>

Assigning a value to a variable is a statement, it doesn't return anything.

```rust
let num = 5;
```

Expressions can be part of a statement.
While that line is a statement, it contains an expression (something that evaluates to a value).
In this case, the value itself, the integer `5`.

<Aside variant="danger">

Variable assignment being a statement is the reason you can't assign a value to the result of another assignment, like in many other languages.

The following snippet would try to assign "nothing" to the `also_num` variable, that's an error!

```rust
let also_num = (let num = 5); // error!
```

</Aside>

<Aside variant="info">

Statements technically return something. Rust's way to express "nothing here", the empty tuple `()`.

</Aside>

Function bodies are made up of a series of statements, optionally ending in an expression.

Expressions do not include ending semicolons.
If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.

If a function ends in an expression, it returns the value of that expression.

A function definition itself is also a statement, it does not result in a value.
Calling a function is an expression, that expression evaluates to whatever that function call returns.

```rust
let num = add(4, 1);

fn add(x: i32, y:i32) -> i32 {
    x + y
}
```

The lines where the `add` function is defined, is a statement, those lines don't evaluate to anything.  
Calling `add(4, 1)` is an expression, it evaluates to a value (the integer `5`).  
Inside the function, the last line of the function body as an expression `x + y`.  
That ending expression evaluates to a value and the function returns it.

<Aside variant="danger">

If that line ended in a semicolon instead `x + y;`, it would turn the expression into a statement.
That would not return a value, causing the function to not return a value.

That would mean we lied when we defined the function, as we stated it would return an integer of type `i32` (with the syntax `-> i32`).
The function doesn't do that anymore.
It returns nothing now.

This is a bug and the Rust compiler won't let you do this.

</Aside>

That value is then assigned to the variable named `num`, that entire line (`let num = add(4, 1);`) is a statement.

A codeblock that creates a new scope is an expression (it evaluates to a value).

```rust
let num = {
    let x = 4;
    x + 1
};
```

Inside that codeblock, a variable declaration statement happens, followed by an expression (`x + 1`).
The block is an expression itself, it evaluates to a value and assigns it to the `num` variable.

---

You may explicitly return a value from a function by using the `return` keyword, followed by an expression.

This `add` function that explicitly ends execution and returns a value is equivalent to the one that was used above.

```rust
fn add(x: i32, y:i32) -> i32 {
    return x + y;
}
```

---

We can use this mechanism to make code that has a variable declaration that is only used to later be populated a bit shorter.

Long example:

```rust
fn main() {
    let num = 5;
    let mut name = "";
    if num > 3 {
        name = "Jon";
    } else {
        name = "Mike";
    }
    println!("{}", name);
}
```

`if` is an expression, it returns a value.
The value it evaluates to is whatever the value of de codeblock it executed evaluated to.
That means we can rewrite our example above, and never have `name` as empty string.

```rust
fn main() {
    let num = 5;
    let name = if num > 3 {
        "Jon"
    } else {
        "Mike"
    };
    println!("{}", name);
}
```

This has the result that every arm of the `if` statement must return the same type.
If we return different types from the branches, the compiler won't be able to figure out what resulting type of the entire `if` is and will show a compilation error.

A similar approach can be taken with more programming constructs in Rust that are expressions: like `match`, `loop`, ...
